# NOVA HR 1.0

[![wemake-python-styleguide](https://img.shields.io/badge/style-wemake-000000.svg)](https://github.com/wemake-services/wemake-python-styleguide)

### Описание

Цифровой ассистент сотрудника по подбору персонала:

[Демо версия проекта](http://hr.nautilus.com.ru/) 

### Установка

Устанавливаем python3

```sh
sudo apt install python3
sudo apt install python3-pip
```

Клонируем проект

```sh
git clone https://github.com/sanchos2/prime_geeks_final.git
cd prime_geeks_final

```

Создаем виртуальное окружение, активируем его и  устанавливаем зависимости

```sh
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```
Для разработки переменные окружения можно не указывать - при этом будут использованы default значения
Для production среды добавляем переменные окружения в .env файл и размещаем его в корне проекта

```
DEBUG=True
SECRET_KEY=superkey
ALLOWED_HOSTS=127.0.0.1 localhost [::1]
DB_ENGINE=django.db.backends.postgresql
DB_HOST=localhost
DB_PORT=5432
DB_NAME=base
DB_USER=user
DB_PASSWORD=pa$$word

```
Для работы в production среде Debug установить в False 

### Запуск

Запуск проекта
Активируем виртуальное окружение, применяем миграции к базе данных.

```sh
python manage.py migration
python manage.py createsuperuser
```

Создаем пользователя с правами администратора, собираем статику и  запускаем сервер для разработки

```
python manage.py collectstatic  # только в production
python manage.py runserver
```


Переходим по адресу http://127.0.0.1:8000
Панель администратора доступна по адресу http://127.0.0.1:8000/admin


### Справка
В проекте используется несколько функциональных алгоритмов:
1. Поиск шаблонов (vacancy_templates.py):

    1.1. TFIDF - метод векторизации слов по композитной метрике частотности (tf - total frequency - общее число вхождений слова, idf - inversed d-чего-то там frequence). Важно понимать, что это не нейросеть.
    Применяем это.
    
    1.2. Результат кладём в корреляционную матрицу и смотрим всё, что коррелирует между собой на 0.7 и больше (но не на 1, иначе это полные дубликаты).
    На этом этапе мы получаем список наиболее похожих пар на рынке. По сути если мы возьмем для конкретной вакансии все полученные пары, а потом сведем их в единый файл, мы увидим некий усредненный отраслевой стандарт по рынку.
    
    1.3. Непосредственно выдача шаблонов происходит следующим образом. Программа получает список всех вакансий с названием создаваемой вакансии, отсекает только соответствующие пары из предыдущего пункта, после чего делает нарезку обязанностей и требований.
    
2. Поиск кандидатов (vacancy_cv_match.py):

    2.1. Чистка на адекватность данных: убираем всех несовершеннолетних, убираем плохо заполненные резюме, резюме без образования, без последнего места работы, без возраста.
    
    2.2. Сравниваем work_type (график), выбираем тех, кто подходит.
    
    2.3. Сравниваем зп - порог +-20% к зп вакансии. Если за этот порог выходит, отсекаем.
    
    2.4. Здесь TFIDF + корреляционный анализ на обязанности с последнего места работы и требования в вакансии. Ищем топ коррелированных резюме с вакансией => это наш список кандидатов, которым уйдет тестовое задание.
    
3. Парсер вакансий (datagrabber.py, resume_hh_parser.py)

    3.1. Парсит вакансии с сервисов hh.ru, geekjob.ru, habr.ru, заносит данные в базу данных на которой основываются данные других алгоритмов.

-=Prime Geeks=-
